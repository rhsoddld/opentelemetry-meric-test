{"version":3,"file":"PrometheusSerializer.js","sourceRoot":"","sources":["../../src/PrometheusSerializer.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  MetricRecord,\n  AggregatorKind,\n  MetricKind,\n} from '@opentelemetry/sdk-metrics-base';\nimport { PrometheusCheckpoint } from './types';\nimport { Attributes } from '@opentelemetry/api-metrics';\nimport { hrTimeToMilliseconds } from '@opentelemetry/core';\n\ntype PrometheusDataTypeLiteral =\n  | 'counter'\n  | 'gauge'\n  | 'histogram'\n  | 'summary'\n  | 'untyped';\n\nfunction escapeString(str: string) {\n  return str.replace(/\\\\/g, '\\\\\\\\').replace(/\\n/g, '\\\\n');\n}\n\nfunction escapeAttributeValue(str: string) {\n  if (typeof str !== 'string') {\n    str = String(str);\n  }\n  return escapeString(str).replace(/\"/g, '\\\\\"');\n}\n\nconst invalidCharacterRegex = /[^a-z0-9_]/gi;\n/**\n * Ensures metric names are valid Prometheus metric names by removing\n * characters allowed by OpenTelemetry but disallowed by Prometheus.\n *\n * https://prometheus.io/docs/concepts/data_model/#metric-names-and-attributes\n *\n * 1. Names must match `[a-zA-Z_:][a-zA-Z0-9_:]*`\n *\n * 2. Colons are reserved for user defined recording rules.\n * They should not be used by exporters or direct instrumentation.\n *\n * OpenTelemetry metric names are already validated in the Meter when they are created,\n * and they match the format `[a-zA-Z][a-zA-Z0-9_.\\-]*` which is very close to a valid\n * prometheus metric name, so we only need to strip characters valid in OpenTelemetry\n * but not valid in prometheus and replace them with '_'.\n *\n * @param name name to be sanitized\n */\nfunction sanitizePrometheusMetricName(name: string): string {\n  return name.replace(invalidCharacterRegex, '_'); // replace all invalid characters with '_'\n}\n\n/**\n * @private\n *\n * Helper method which assists in enforcing the naming conventions for metric\n * names in Prometheus\n * @param name the name of the metric\n * @param kind the kind of metric\n * @returns string\n */\nfunction enforcePrometheusNamingConvention(\n  name: string,\n  kind: MetricKind\n): string {\n  // Prometheus requires that metrics of the Counter kind have \"_total\" suffix\n  if (!name.endsWith('_total') && kind === MetricKind.COUNTER) {\n    name = name + '_total';\n  }\n\n  return name;\n}\n\nfunction valueString(value: number) {\n  if (Number.isNaN(value)) {\n    return 'Nan';\n  } else if (!Number.isFinite(value)) {\n    if (value < 0) {\n      return '-Inf';\n    } else {\n      return '+Inf';\n    }\n  } else {\n    return `${value}`;\n  }\n}\n\nfunction toPrometheusType(\n  metricKind: MetricKind,\n  aggregatorKind: AggregatorKind\n): PrometheusDataTypeLiteral {\n  switch (aggregatorKind) {\n    case AggregatorKind.SUM:\n      if (\n        metricKind === MetricKind.COUNTER ||\n        metricKind === MetricKind.OBSERVABLE_COUNTER\n      ) {\n        return 'counter';\n      }\n      /** MetricKind.UP_DOWN_COUNTER and MetricKind.OBSERVABLE_UP_DOWN_COUNTER */\n      return 'gauge';\n    case AggregatorKind.LAST_VALUE:\n      return 'gauge';\n    case AggregatorKind.HISTOGRAM:\n      return 'histogram';\n    default:\n      return 'untyped';\n  }\n}\n\nfunction stringify(\n  metricName: string,\n  attributes: Attributes,\n  value: number,\n  timestamp?: number,\n  additionalAttributes?: Attributes\n) {\n  let hasAttribute = false;\n  let attributesStr = '';\n\n  for (const [key, val] of Object.entries(attributes)) {\n    const sanitizedAttributeName = sanitizePrometheusMetricName(key);\n    hasAttribute = true;\n    attributesStr += `${\n      attributesStr.length > 0 ? ',' : ''\n    }${sanitizedAttributeName}=\"${escapeAttributeValue(val)}\"`;\n  }\n  if (additionalAttributes) {\n    for (const [key, val] of Object.entries(additionalAttributes)) {\n      const sanitizedAttributeName = sanitizePrometheusMetricName(key);\n      hasAttribute = true;\n      attributesStr += `${\n        attributesStr.length > 0 ? ',' : ''\n      }${sanitizedAttributeName}=\"${escapeAttributeValue(val)}\"`;\n    }\n  }\n\n  if (hasAttribute) {\n    metricName += `{${attributesStr}}`;\n  }\n\n  return `${metricName} ${valueString(value)}${\n    timestamp !== undefined ? ' ' + String(timestamp) : ''\n  }\\n`;\n}\n\nexport class PrometheusSerializer {\n  private _prefix: string | undefined;\n  private _appendTimestamp: boolean;\n\n  constructor(prefix?: string, appendTimestamp = true) {\n    if (prefix) {\n      this._prefix = prefix + '_';\n    }\n    this._appendTimestamp = appendTimestamp;\n  }\n\n  serialize(checkpointSet: PrometheusCheckpoint[]): string {\n    let str = '';\n    for (const checkpoint of checkpointSet) {\n      str += this.serializeCheckpointSet(checkpoint) + '\\n';\n    }\n    return str;\n  }\n\n  serializeCheckpointSet(checkpoint: PrometheusCheckpoint): string {\n    let name = sanitizePrometheusMetricName(\n      escapeString(checkpoint.descriptor.name)\n    );\n    if (this._prefix) {\n      name = `${this._prefix}${name}`;\n    }\n\n    name = enforcePrometheusNamingConvention(\n      name,\n      checkpoint.descriptor.metricKind\n    );\n\n    const help = `# HELP ${name} ${escapeString(\n      checkpoint.descriptor.description || 'description missing'\n    )}`;\n    const type = `# TYPE ${name} ${toPrometheusType(\n      checkpoint.descriptor.metricKind,\n      checkpoint.aggregatorKind\n    )}`;\n\n    const results = checkpoint.records\n      .map(it => this.serializeRecord(name, it))\n      .join('');\n\n    return `${help}\\n${type}\\n${results}`.trim();\n  }\n\n  serializeRecord(name: string, record: MetricRecord): string {\n    let results = '';\n\n    name = enforcePrometheusNamingConvention(\n      name,\n      record.descriptor.metricKind\n    );\n\n    switch (record.aggregator.kind) {\n      case AggregatorKind.SUM:\n      case AggregatorKind.LAST_VALUE: {\n        const { value, timestamp: hrtime } = record.aggregator.toPoint();\n        const timestamp = hrTimeToMilliseconds(hrtime);\n        results += stringify(\n          name,\n          record.attributes,\n          value,\n          this._appendTimestamp ? timestamp : undefined,\n          undefined\n        );\n        break;\n      }\n      case AggregatorKind.HISTOGRAM: {\n        const { value, timestamp: hrtime } = record.aggregator.toPoint();\n        const timestamp = hrTimeToMilliseconds(hrtime);\n        /** Histogram[\"bucket\"] is not typed with `number` */\n        for (const key of ['count', 'sum'] as ('count' | 'sum')[]) {\n          results += stringify(\n            name + '_' + key,\n            record.attributes,\n            value[key],\n            this._appendTimestamp ? timestamp : undefined,\n            undefined\n          );\n        }\n\n        let cumulativeSum = 0;\n        const countEntries = value.buckets.counts.entries();\n        let infiniteBoundaryDefined = false;\n        for (const [idx, val] of countEntries) {\n          cumulativeSum += val;\n          const upperBound = value.buckets.boundaries[idx];\n          /** HistogramAggregator is producing different boundary output -\n           * in one case not including inifinity values, in other -\n           * full, e.g. [0, 100] and [0, 100, Infinity]\n           * we should consider that in export, if Infinity is defined, use it\n           * as boundary\n           */\n          if (upperBound === undefined && infiniteBoundaryDefined) {\n            break;\n          }\n          if (upperBound === Infinity) {\n            infiniteBoundaryDefined = true;\n          }\n          results += stringify(\n            name + '_bucket',\n            record.attributes,\n            cumulativeSum,\n            this._appendTimestamp ? timestamp : undefined,\n            {\n              le:\n                upperBound === undefined || upperBound === Infinity\n                  ? '+Inf'\n                  : String(upperBound),\n            }\n          );\n        }\n        break;\n      }\n    }\n    return results;\n  }\n}\n"]}