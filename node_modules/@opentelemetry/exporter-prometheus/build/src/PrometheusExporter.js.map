{"version":3,"file":"PrometheusExporter.js","sourceRoot":"","sources":["../../src/PrometheusExporter.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { diag } from '@opentelemetry/api';\nimport {\n  ExportResult,\n  globalErrorHandler,\n  ExportResultCode,\n} from '@opentelemetry/core';\nimport { MetricExporter, MetricRecord } from '@opentelemetry/sdk-metrics-base';\nimport { createServer, IncomingMessage, Server, ServerResponse } from 'http';\nimport * as url from 'url';\nimport { ExporterConfig } from './export/types';\nimport { PrometheusSerializer } from './PrometheusSerializer';\nimport { PrometheusAttributesBatcher } from './PrometheusAttributesBatcher';\n\nexport class PrometheusExporter implements MetricExporter {\n  static readonly DEFAULT_OPTIONS = {\n    host: undefined,\n    port: 9464,\n    endpoint: '/metrics',\n    prefix: '',\n    appendTimestamp: true,\n  };\n\n  private readonly _host?: string;\n  private readonly _port: number;\n  private readonly _endpoint: string;\n  private readonly _server: Server;\n  private readonly _prefix?: string;\n  private readonly _appendTimestamp: boolean;\n  private _serializer: PrometheusSerializer;\n  private _batcher = new PrometheusAttributesBatcher();\n\n  // This will be required when histogram is implemented. Leaving here so it is not forgotten\n  // Histogram cannot have a attribute named 'le'\n  // private static readonly RESERVED_HISTOGRAM_LABEL = 'le';\n\n  /**\n   * Constructor\n   * @param config Exporter configuration\n   * @param callback Callback to be called after a server was started\n   */\n  constructor(config: ExporterConfig = {}, callback?: () => void) {\n    this._host =\n      config.host ||\n      process.env.OTEL_EXPORTER_PROMETHEUS_HOST ||\n      PrometheusExporter.DEFAULT_OPTIONS.host;\n    this._port =\n      config.port ||\n      Number(process.env.OTEL_EXPORTER_PROMETHEUS_PORT) ||\n      PrometheusExporter.DEFAULT_OPTIONS.port;\n    this._prefix = config.prefix || PrometheusExporter.DEFAULT_OPTIONS.prefix;\n    this._appendTimestamp =\n      typeof config.appendTimestamp === 'boolean'\n        ? config.appendTimestamp\n        : PrometheusExporter.DEFAULT_OPTIONS.appendTimestamp;\n    // unref to prevent prometheus exporter from holding the process open on exit\n    this._server = createServer(this._requestHandler).unref();\n    this._serializer = new PrometheusSerializer(\n      this._prefix,\n      this._appendTimestamp\n    );\n\n    this._endpoint = (\n      config.endpoint || PrometheusExporter.DEFAULT_OPTIONS.endpoint\n    ).replace(/^([^/])/, '/$1');\n\n    if (config.preventServerStart !== true) {\n      this.startServer()\n        .then(callback)\n        .catch(err => diag.error(err));\n    } else if (callback) {\n      callback();\n    }\n  }\n\n  /**\n   * Saves the current values of all exported {@link MetricRecord}s so that\n   * they can be pulled by the Prometheus backend.\n   *\n   * In its current state, the exporter saves the current values of all metrics\n   * when export is called and returns them when the export endpoint is called.\n   * In the future, this should be a no-op and the exporter should reach into\n   * the metrics when the export endpoint is called. As there is currently no\n   * interface to do this, this is our only option.\n   *\n   * @param records Metrics to be sent to the prometheus backend\n   * @param cb result callback to be called on finish\n   */\n  export(records: MetricRecord[], cb: (result: ExportResult) => void): void {\n    if (!this._server) {\n      // It is conceivable that the _server may not be started as it is an async startup\n      // However unlikely, if this happens the caller may retry the export\n      cb({ code: ExportResultCode.FAILED });\n      return;\n    }\n\n    diag.debug('Prometheus exporter export');\n\n    for (const record of records) {\n      this._batcher.process(record);\n    }\n\n    cb({ code: ExportResultCode.SUCCESS });\n  }\n\n  /**\n   * Shuts down the export server and clears the registry\n   */\n  shutdown(): Promise<void> {\n    return this.stopServer();\n  }\n\n  /**\n   * Stops the Prometheus export server\n   */\n  stopServer(): Promise<void> {\n    if (!this._server) {\n      diag.debug(\n        'Prometheus stopServer() was called but server was never started.'\n      );\n      return Promise.resolve();\n    } else {\n      return new Promise(resolve => {\n        this._server.close(err => {\n          if (!err) {\n            diag.debug('Prometheus exporter was stopped');\n          } else {\n            if (\n              ((err as unknown) as { code: string }).code !==\n              'ERR_SERVER_NOT_RUNNING'\n            ) {\n              globalErrorHandler(err);\n            }\n          }\n          resolve();\n        });\n      });\n    }\n  }\n\n  /**\n   * Starts the Prometheus export server\n   */\n  startServer(): Promise<void> {\n    return new Promise(resolve => {\n      this._server.listen(\n        {\n          port: this._port,\n          host: this._host,\n        },\n        () => {\n          diag.debug(\n            `Prometheus exporter server started: ${this._host}:${this._port}/${this._endpoint}`\n          );\n          resolve();\n        }\n      );\n    });\n  }\n\n  /**\n   * Request handler that responds with the current state of metrics\n   * @param request Incoming HTTP request of server instance\n   * @param response HTTP response objet used to response to request\n   */\n  public getMetricsRequestHandler(\n    _request: IncomingMessage,\n    response: ServerResponse\n  ): void {\n    this._exportMetrics(response);\n  }\n\n  /**\n   * Request handler used by http library to respond to incoming requests\n   * for the current state of metrics by the Prometheus backend.\n   *\n   * @param request Incoming HTTP request to export server\n   * @param response HTTP response object used to respond to request\n   */\n  private _requestHandler = (\n    request: IncomingMessage,\n    response: ServerResponse\n  ) => {\n    if (url.parse(request.url!).pathname === this._endpoint) {\n      this._exportMetrics(response);\n    } else {\n      this._notFound(response);\n    }\n  };\n\n  /**\n   * Responds to incoming message with current state of all metrics.\n   */\n  private _exportMetrics = (response: ServerResponse) => {\n    response.statusCode = 200;\n    response.setHeader('content-type', 'text/plain');\n    if (!this._batcher.hasMetric) {\n      response.end('# no registered metrics');\n      return;\n    }\n    response.end(this._serializer.serialize(this._batcher.checkPointSet()));\n  };\n\n  /**\n   * Responds with 404 status code to all requests that do not match the configured endpoint.\n   */\n  private _notFound = (response: ServerResponse) => {\n    response.statusCode = 404;\n    response.end();\n  };\n}\n"]}